"""Wrapper around Qt libraries to make it easier to swap out backends in the future
"""
import os
import sys

import pyqtgraph as pg

# make one large namespace containing everything; pyqtgraph handles translation
# between different Qt versions
for mod in [pg.Qt, pg.Qt.QtGui, pg.Qt.QtCore, pg.Qt.QtTest, pg.Qt.QtWidgets]:
    ns = mod.__dict__.copy()
    # don't copy special variables like __name__, __file__, etc.
    for k in list(ns.keys()):
        if k.startswith('__'):
            ns.pop(k)
    globals().update(ns)

# signal disconnect with exception handling
# allows (calling disconnect even if no connection currently exists)
disconnect = pg.disconnect


def loadUiType(uiFile, package=None):
    if QT_LIB == PYQT5:
        from PyQt5 import uic
    elif QT_LIB == PYQT6:
        from PyQt6 import uic
    elif QT_LIB == PYSIDE2:
        from PySide2 import uic
    else:
        raise ImportError("compileUi could not be imported from PyQt5, PyQt6 or PySide2")
    import xml.etree.ElementTree as xml

    parsed = xml.parse(uiFile)
    widget_class = parsed.find('widget').get('class')
    form_class = parsed.find('class').text

    if package is None:
        globalns = {}
    else:
        globalns = {'__package__': package}

    # load, compile, and execute ui code
    o = _StringIO()
    uic.compileUi(open(uiFile, 'r'), o, indent=0)
    pyc = compile(o.getvalue(), uiFile, 'exec')
    exec(pyc, globalns)

    # Fetch the base_class and form class based on their type in the xml from designer
    form_class = globalns[f'Ui_{form_class}']
    base_class = getattr(QtWidgets, widget_class)

    return form_class, base_class


def importTemplate(templateName):
    """Return the template class generated by a .ui file for the Qt system 
    currently in use.
    
    If the module path is relative (starts with "."), then the root package is
    inferred by inspecting the frame stack.
    
    For example::
    
        Ui_MainWindow = Qt.importTemplate('.MyTemplate')
        
        # For PyQt4, this is equivalent to
        from .MyTemplate import Ui_MainWindow
        
        # for PyQt5, this is equivalent to
        from .MyTemplate_pyqt5 import Ui_MainWindow
    """
    frame = sys._getframe().f_back
    pkg = frame.f_globals['__package__']

    # Find location of calling module
    modParts = pkg.split('.')
    mod = sys.modules[modParts.pop(0)]
    root = os.path.dirname(mod.__file__)

    # construct full path to ui file
    ndots = len(templateName) - len(templateName.lstrip('.'))
    if ndots > 1:
        modParts = modParts[:-ndots]
    pathParts = modParts + templateName.lstrip('.').split('.')
    uipath = os.path.join(root, *pathParts) + '.ui'
    if not os.path.isfile(uipath):
        raise ValueError("ui file not found: %r" % uipath)
    return loadUiType(uipath, package=pkg)[0]


class FlowLayout(pg.QtWidgets.QLayout):
    """From https://doc.qt.io/qtforpython/examples/example_widgets_layouts_flowlayout.html"""
    def __init__(self, parent=None):
        super().__init__(parent)

        if parent is not None:
            self.setContentsMargins(QMargins(0, 0, 0, 0))

        self._item_list = []

    def __del__(self):
        item = self.takeAt(0)
        while item:
            item = self.takeAt(0)

    def addItem(self, item):
        self._item_list.append(item)

    def clear(self):
        for i in reversed(range(self.count())):
            self.itemAt(i).widget().setParent(None)
        self._item_list = []

    def count(self):
        return len(self._item_list)

    def itemAt(self, index):
        if 0 <= index < len(self._item_list):
            return self._item_list[index]

        return None

    def takeAt(self, index):
        if 0 <= index < len(self._item_list):
            return self._item_list.pop(index)

        return None

    def expandingDirections(self):
        return Qt.Orientation(0)

    def hasHeightForWidth(self):
        return True

    def heightForWidth(self, width):
        return self._do_layout(QRect(0, 0, width, 0), True)

    def setGeometry(self, rect):
        super(FlowLayout, self).setGeometry(rect)
        self._do_layout(rect, False)

    def sizeHint(self):
        return self.minimumSize()

    def minimumSize(self):
        size = QSize()

        for item in self._item_list:
            size = size.expandedTo(item.minimumSize())

        size += QSize(2 * self.contentsMargins().top(), 2 * self.contentsMargins().top())
        return size

    def _do_layout(self, rect, test_only):
        x = rect.x()
        y = rect.y()
        line_height = 0
        spacing = self.spacing()

        for item in self._item_list:
            style = item.widget().style()
            layout_spacing_x = style.layoutSpacing(
                QSizePolicy.PushButton, QSizePolicy.PushButton, Qt.Horizontal
            )
            layout_spacing_y = style.layoutSpacing(
                QSizePolicy.PushButton, QSizePolicy.PushButton, Qt.Vertical
            )
            space_x = spacing + layout_spacing_x
            space_y = spacing + layout_spacing_y
            next_x = x + item.sizeHint().width() + space_x
            if next_x - space_x > rect.right() and line_height > 0:
                x = rect.x()
                y = y + line_height + space_y
                next_x = x + item.sizeHint().width() + space_x
                line_height = 0

            if not test_only:
                item.setGeometry(QRect(QPoint(x, y), item.sizeHint()))

            x = next_x
            line_height = max(line_height, item.sizeHint().height())

        return y + line_height - rect.y()
