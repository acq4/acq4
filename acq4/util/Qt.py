"""Wrapper around Qt libraries to make it easier to swap out backends in the future
"""
from __future__ import print_function
import os, sys, importlib, inspect


# try importing Qt libraries in order of preference
qtLibs = ['PyQt5', 'PyQt4', 'PySide', 'PySide2', None]
for mod in qtLibs:
    if mod is None:
        raise Exception("Could not import any Qt libraries (tried PyQt5, PyQt4, PySide, PySide2).")
    try:
        importlib.import_module(mod)
        break
    except ImportError:
        pass


# If we are using PyQt4, ACQ4 requires API version 2 for QString and QVariant. 
# Check for those here..
if 'PyQt4' in sys.modules:
    import sip
    for api in ['QString', 'QVariant']:
        try:
            v = sip.getapi(api)
            if v != 2:
                print("WARNING: ACQ4 requires the use of API version 2 for QString and QVariant, but %s=%s. "
                      "Correct this by calling \"import sip; sip.setapi('QString', 2); sip.setapi('QVariant', 2);\""
                      " _before_ importing PyQt4." % (api, v))
        except ValueError:
            sip.setapi(api, 2)
            print("SIP API", api)


from .. import pyqtgraph as pg


# make one large namespace containing everything; pyqtgraph handles translation
# between different Qt versions
globals().update(pg.Qt.__dict__)
globals().update(pg.Qt.QtGui.__dict__)
globals().update(pg.Qt.QtCore.__dict__)
globals().update(pg.Qt.QtTest.__dict__)
#globals().update(importlib.import_module(pg.Qt.QT_LIB + '.QtSql').__dict__)

# signal disconnect with exception handling
# allows (calling disconnect even if no connection currently exists)
disconnect = pg.disconnect


def importTemplate(templateName):
    """Return the template class generated by a .ui file for the Qt system 
    currently in use.
    
    If the module path is relative (starts with "."), then the root package is
    inferred by inspecting the frame stack.
    
    For example::
    
        Ui_MainWindow = Qt.importTemplate('.MyTemplate')
        
        # For PyQt4, this is equivalent to
        from .MyTemplate import Ui_MainWindow
        
        # for PyQt5, this is equivalent to
        from .MyTemplate_pyqt5 import Ui_MainWindow
    """
    modName = templateName
    if pg.Qt.QT_LIB == 'PyQt5':
        modName = modName + '_pyqt5'

    frame = sys._getframe().f_back
    pkg = frame.f_globals['__package__']

    try:    
        if modName[0] != '.':
            pkg = None
        # try importing pre-compiled template file first
        mod = importlib.import_module(modName, package=pkg)
        for k,v in mod.__dict__.items():
            if k[:3] == 'Ui_' and inspect.isclass(v):
                return v        
        raise Exception("Could not find Ui_* class in module %s" % modName)
    except Exception:
        # otherwise, try dynamic read from .ui file

        # Find location of calling module 
        modParts = pkg.split('.')
        mod = sys.modules[modParts.pop(0)]
        root = os.path.dirname(mod.__file__)

        # construct full path to ui file
        ndots = len(templateName) - len(templateName.lstrip('.'))
        if ndots > 1:
            modParts = modParts[:-ndots]
        pathParts = modParts + templateName.lstrip('.').split('.')
        uipath = os.path.join(root, *pathParts) + '.ui'
        if not os.path.isfile(uipath):
            raise ValueError("ui file not found: %r" % uipath)
        return loadUiType(uipath, package=pkg)[0]
